# 探索 TypeScript 类型注解 - 高级类型
> Exploring TypeScript Type Annotations - Advance Types
>> 本文由 [WowBar][WowBar] 团队首发于 [GitHub][this-post]
>>> 作者: zhilidali

欢迎来到 __[《探索 TypeScript 类型注解》][Explore-TS]__ 系列教程。
[上一篇][prev-post]介绍了类型检查机制，本篇深入探索高级类型。

## 目录

+ [交叉类型](#交叉类型)
+ [联合类型](#联合类型)
+ [索引类型](#索引类型)
+ [映射类型](#映射类型)
+ [条件类型](#条件类型)

## 交叉类型

交叉类型将多个类型合为一个类型: `T & U`
```ts
interface TypeA { a: number }
interface TypeB { b: number }
let a: TypeA = { a: 1 };
let b: TypeB = { b: 2 };
let c: TypeA & TypeB = { ...a, ...b };
```

## 联合类型

联合类型表示一个值可以是几种类型之一: `T | U`

具有联合类型的值只能访问类型的共有成员
```ts
// Union Type
let tsUnion: number | string = 1;
tsUnion.length; // error: only access common members
```

## 索引类型

### 索引类型查询操作符

`keyof T`：表示为 T 的公有属性名的联合
```ts
interface F { a: string; b: number; }

type foo = keyof F;
// type foo = 'a' | 'b'
```

如果类型 `T` 带有字符串索引签名，那么 `keyof T` 为 `string | number` 类型
如果类型 `T` 带有数字索引签名，那么 `keyof T `为 `number` 类型。
```ts
interface B { [index: string]: string; }

type bar = keyof B;
// type bar = string | number
```

### 索引访问操作符

`T[K]`：表示 `T` 的属性 `K` 的类型
```ts
interface F { a: string; b: number; }

type foo = F['a'];
// type foo = string
```

## 映射类型

映射类型可以基于旧类型创建新类型

`[K in T]: Type`：类型变量 `K` 会把字符串字面量联合类型 `T` 的每个字符串都映射为属性
```ts
type Foo = 'a' | 'b';
type Bar = {
	[K in Foo]: number;
}
// 等同于：
// type Bar = {
// 	a: number;
// 	b: number;
// }
```

在映射类型中，新类型可以相同的形式转换旧类型中的每个属性，例如，例如，可以将类型的所有属性设置为可选或只读。
```ts
interface Foo {
	a: number;
	b: number;
}

type FooPartial = {
	[P in keyof Foo]?: Foo[P];
}
// 等同于：
// type FooPartial = {
// 	a?: number | undefined;
// 	b?: number | undefined;
// }

type FooReadonly = {
	readonly [P in keyof Foo]: Foo[P];
}
// 等同于：
// type FooReadonly = {
// 	readonly a: number;
// 	readonly b: number;
// }
```

由于转换为只读或可选等功能非常有用，它们被包含在TypeScript的标准库中, 详情见下篇[实用工具类型][next-post]
```ts
type Partial<T> = {
	[P in keyof T]?: T[P];
}
type Readonly<T> = {
	readonly [P in keyof T]: T[P];
}
```

## 条件类型

`T extends U ? X : Y`: 如果 `T` 可以赋值给 `U`，那么类型是 `X`，否则为 `Y`
```ts
type TypeName<T> = T extends string ? "string" : "number";

type Foo = TypeName<'ts'>;
// type Foo = "string"

type Bar = TypeName<number>;
// type Bar = "number"
```

嵌套条件类型
```ts
type TypeName<T> =
	T extends string ? 'string' :
	T extends number ? 'number' :
	T extends boolean ? 'boolean' :
	T extends undefined ? 'undefined' :
	T extends Function ? 'function' :
	'object';

type Foo = TypeName<string>;
// type Foo = "string"

type Bar = TypeName<true>;
// type Bar = "boolean"
```

分布式条件类型：如参数 `T` 为 `A ｜ B`，条件类型会自动解析为 `(A extends U ? X : Y) | (B extends U ? X : Y)`
```ts
type Baz = TypeName<1 | false>
// type Baz = "number" | "boolean"
```

条件类型中的类型推断：在 `extends` 子句中，允许使用 `infer` 声明一个类型变量，可以在 true 分支中被引用
```ts
type A<T> = T extends { a: infer U } ? U : any;

type Foo = A<{ a: number }>
// type Foo = number
type Bar = A<number>
// type Bar = any
```

```ts
type A<T> = T extends { a: infer U, b: infer U } ? U : any;

type Foo = A<{ a: number, b: string }>
// type Foo = string | number
```

__结语__
本篇介绍了类型的高级类型，[下篇][next-post]将探索 TypeScript 提供的实用工具类型。

[![CC BY-NC-ND 4.0](https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png "LICENSE")][License]

本作品采用[知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议][by-nc-nd]进行许可。

[License]:    https://github.com/WowBar/blog/blob/master/LICENSE.md
[by-nc-nd]:   http://creativecommons.org/licenses/by-nc-nd/4.0/
[WowBar]:     https://github.com/WowBar/blog
[Explore-TS]: https://github.com/WowBar/blog/labels/ExploringTS
[prev-post]:  https://github.com/WowBar/blog/issues/11
[this-post]:  https://github.com/WowBar/blog/issues/13
[next-post]:  https://github.com/WowBar/blog/issues/14
