# 语句与表达式
JavaScript中的语句和表达式的区别在于**语句执行动作，表达式产生值**。可以在任何需要语句的地方写表达式（称为表达式语句），相反，在任何需要表达式的地方写语句就不行。
语句也获取不到值

## 一. 语句
<!-- 单个语句可以跨多行。每个语句可用分号隔开在一行中出现。 -->

+ ### 分类
    - 声明语句
        1. 变量声明：var, let, const
        2. 函数声明：function, function*, async function
        3. 类声明：class

    - 流程控制语句
        1. 块语句: 组合0或多个语句, 可以与label一起用
            写法：`{语句组合} 或 标签标识符: {语句组合}`

            ```js
            // 示例1
            var a = 1;
            {
                var a = 2;
            }
            console.log(a);  // 2

            // 示例2
            const a = 1;
            {
                const a = 2;
            }
            console,log(a); // 1
                
            label: {
                const a = 1;
            }
            ```

            上面可以看出示例2不会报错，因为块级作用域的存在，并且输出的是1。

            块返回的值为块中最后一条语句的返回值，不过因为语句的值获取不到，所以了解即可。
            ```js
            var a;
            function b() {return 'yang';}
            try {
                throw 'haha';
            } catch(e) {
            }
            // 语句返回 <· undefined

            var a;
            function b() {return 'yang';}
            // <· ƒ b() {return 'yang';}
            ```

        2. 空语句: 不会执行任何语句
            写法：`;`

            ```js
            // 跟for循环一起的空语句（空语句最好写注释以防混淆）
            for (let i = 0; i < 5; i++) /* Empty statement */;  

            // if语句
            if (one); // do nothing
            else if (two); // do nothing
            else
                all();
            ```

        3. break语句: 中止当前循环（或switch语句 或 label语句），直接执行被中止语句后面的语句。
            写法：`break [label]; `
            label(可选)-标签相关标识符，如果break语句不在一个循环或switch语句中，则该项是必须的。

            ```js
            // 示例1: 循环中的break语句
            var i = 0;
            while (i < 6) {
                if (i == 3) break;
                i += 1;
                console.log(i);
            }

            // 示例2: break语句和被标记的块语句
            outer_block: {
                inner_block: {
                    console.log('1');
                    break outer_block;
                }
                console.log ('haha') //被跳过
            }
            ```

        4. continue语句: 终止执行当前（或标签）循环的语句，直接执行下一个迭代循环。
            写法：`continue [label]; `
            
            与`break`语句的区别是，continue并不会终止循环的迭代：
            在while循环中，控制流跳转回条件判断；
            在for循环中，控制流跳转到更新语句。

            ```js
                var a = 0;
                var b = 8;

                checkAB: while(...) {
                    checkB: while(...) {
                        continue checkB; //每次都跳到checkB开始执行
                    }
                }
            ```

        5. if语句：条件判断
            写法：
            ```js
                if (condition)
                    statement1
                [else if (condition)
                    statement2]
                [else
                    statement3] 
                //中括号表示可选
            ```

        6. switch语句：评估一个表达式，若表达式的值与case子句匹配则执行case子句相关联的语句。
            写法：
            ```js
            switch (expression) {
                case value1:
                    // 当 expression 的结果与 value1 匹配时，执行此处语句
                    [break;]
                ...
                [default:
                    // 如果 expression 与上面的 value 值都不匹配，执行此处语句
                    [break;]]
                // 中括号表示可选
            ```

        7. throw语句：抛出一个用户自定义的异常。当前函数的执行将被停止(throw之后的语句将不会执行)，并且控制将被传递到调用堆栈中的第一个catch块。如果调用函数中没有catch块，程序将会终止。
            写法：`throw expression;`
            ```js
            throw "Error2"; // 抛出了一个值为字符串的异常
            throw 42;       // 抛出了一个值为整数42的异常
            throw true;     // 抛出了一个值为true的异常
            ```

        8. try...catch语句
            标记要尝试的语句块，并指定一个出现异常时抛出的响应。
            写法：
            ```js
            try {
                try_statements
            }
            [catch (exception_var_1) {}]
            [catch (exception_var_2) {}]
            [finally {}] // 在try块和catch块之后执行，在下一个try声明之前执行，无论是否有异常抛出总是执行
            ```
            exception_var_1, exception_var_2 保存throw语句指定的值(如catch(e)中的e), 可以用这个标识符获取抛出的异常信息，只在catch子句内部使用。

            * 可以嵌套一个或更多的try语句，如果内部的try语句没有catch子句，就会进入包裹它的try语句的catch子句。
                ```js
                try {
                    try {
                        throw new Error("oops");
                    }
                    catch (ex) {
                        console.error("inner", ex.message);
                    }
                    finally {
                        console.log("finally");
                    }
                }
                catch (ex) {
                    console.error("outer", ex.message);
                }
                // Output:
                // "inner" "oops"
                // "finally"
                // "outer" "oops"
                ```

            * finally块返回一个值，无论try和catch块中是否有任何return语句，此值都将成为整个try-catch-finally的返回值。

            ```js
            // try-catch中的return必须是作为函数的返回值才行，不然会报错（见下面return语句）。此中情况下try-catch要放在函数中运行。
            (function() {
                try {
                    try {
                        throw new Error('oops');
                    }
                    catch (ex) {
                        console.error('inner', ex.message);
                        throw ex;
                    }
                    finally {
                        console.log('finally');
                        return;
                    }
                }
                catch (ex) {
                    console.error('outer', ex.message);
                }
            })();

            // Output:
            inner oops
            finally
            undefined // 整个函数的返回值
            ```

        9. return：终止函数的执行，并返回一个指定的值给函数的调用者。
            写法： `return [[expression]]`
            表示：返回表达式的值，如果忽略表达式的值，则会返回undefined.

            在return关键字和被返回的表达式之间若使用行终止符（回车换行符，行分隔符和段分隔符）则会自动分号插入，如：
            ```js
            return
            a + b;
            // 会被自动转换为
            return;
            a + b;

            var a = 1;
            var b = 2;
            (function() {
                return
                a + b;
            })()  // undefined

            // 会被自动转换为
            (function() {
                return a + b;
            })()  // 3
            ```

            也可以返回函数表达式，就是高阶函数。高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。

    - 迭代器语句
        1. while/do...while
            写法：
            ```js
            /**
            * while:
            * 可在某个condition（条件表达式）值为真的前提下，执行循环直到表达式值为false
            */
            while (condition)
                statement // 想执行多行语句可用块语句

            /**
            * do...while:
            * 执行指定语句的循环直到condition（条件表达式）值为false。
            * 与while语句区别在于在执行statement后检测condition，所以statement至少执行一次。
            */
            do
                statement // 想执行多行语句可用块语句
            while (condition);
            ```
            
            两者差别示例：
            ```js
            var i = 1;
            do {
                console.log('do..while', i);
                i++;
            } while (i < 1);
            // 输出：
            // "do...while"
            // 1

            var j = 1;
            while (j < 1) {
                console.log('while', j);
                j++;
            }
            // 没有输出
            ```
            
        2. for/for...in/for...of/for await...of
           * for: 
                创建循环，含三个可选的表达式，表达式包围在圆括号中并由分号分割，后跟一个在循环中执行的语句（通常是一个块语句）。

                写法：
                ```js
                for ([initialization]; [condition]; [final-expression])
                    statement
                // initialization 为一个表达式（包含赋值表达式）或者变量声明
                // 若没有任何语句要执行，则使用空语句(;)
                ```

                如果省略了中间可选的条件表达式(`condition`块)，则必须确保在循环体内跳出(`break语句`)，不然会陷入死循环。
                如果省略所有表达式，则确保跳出循环并且修改增量，使`break语句`在某条件下为true.（见示例2）

                示例：            
                ```js
                // 示例1
                var arr = [];
                for (var i = 0; i < 9; i++) {
                    arr.push(function() {
                        console.log(i);
                    });
                }
                console.log(arr.forEach(item => console.log(item())));
                // Output:
                // [9, 9, 9, 9, 9, 9, 9, 9, 9]

                // 示例2
                var i = 0;

                for (;;) {
                    if (i > 3) break;
                        console.log(i);
                    i++;
                }

                // 示例3
                for (var i = 0; i < 9; i++);
                console.log(i);  // 9
                ```

            * for...of
                循环遍历可迭代对象（Array, Map, Set, String, TypedArray, arguments对象等）要迭代的值。
                写法：
                ```js
                for (variable of iterable) {
                    //statements
                }
                ```

                示例：
                ```js
                // 迭代Array
                let iterable = [10, 20, 30];

                for (let value of iterable) {
                    value += 1;
                    console.log(value);
                }
                // Output:
                // 11
                // 21
                // 31

                // 迭代String
                let iterable = 'boo';

                for (let value of iterable) {
                    console.log(value);
                }
                // b
                // o
                // o

                // 迭代Map
                let iterable = new Map([['a', 1], ['b', 2]]);

                for (let [key, value] of iterable) {
                    console.log(value);
                }
                // 1
                // 2
                ```

            * for...in
                以任意顺序迭代对象的可枚举属性。(除Symbol以外)
                写法：
                ```js
                for (variable in object)
                    statement
                ```

                for...in循环只遍历可枚举属性，不可枚举属性不会遍历，例如String的indexOf()方法，或者Object.toString()方法。
                通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，因为不能保证这些被修改的属性能被访问到。

                for...of循环和for...in循环之间的区别：
                1. for...in 访问Array时不一定会按次序访问元素，这是依赖执行环境的，而且访问的是数组的索引，除了索引外还包括其他的属性以及继承的属性；
                2. for...of 语句遍历可迭代对象要迭代的数据，所以用它来遍历Array里的值更好；
                3. 若只考虑对象自身属性，不包含原型，可以用`getOwnPropertyNames()`或者`hasOwnProperty()`来确定是否是对象自身属性。
                示例：
                ```js
                Object.prototype.objCustom = function() {};
                Array.prototype.arrCustom = function() {};

                let iterable = [3, 5, 7];
                iterable.foo = 'hello';

                for (let i in iterable) {
                    console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
                }

                for (let i in iterable) {
                    if (iterable.hasOwnProperty(i)) {
                        console.log(i); // logs 0, 1, 2, "foo"
                    }
                }

                for (let i of iterable) {
                    console.log(i); // logs 3, 5, 7
                }
                ```

            * for await...of
                在异步或同步可迭代对象上创建一个迭代循环，为每个不同属性的值执行语句。
                写法：
                ```js
                for await (variable of iterable) {
                    statement
                }
                ```

                异步生成器（或迭代异步可迭代对象）已经实现了异步迭代器协议，用for await...of循环：
                ```js
                async function* asyncGenerator() {
                    var i = 0;
                    while (i < 3) {
                        yield i++;
                    }
                }

                (async function() {
                    for await (num of asyncGenerator()) {
                        console.log(num);
                    }
                })();
                // 0
                // 1
                // 2
                ```

    - 其他语句
        1. 调试：debugger
        2. 导入导出：import/export
        3. label
        4. with

## 二. 表达式
+ ### 分类
    - 主要表达式
    - 左表达式
    - 自增表达式
    - 运算符
        * 一元
        * 算术
        * 比较
        * 条件
        * 赋值
        * 逗号
        * 位移，二进制，二元逻辑

## 三. 语句和表达式比较


## 结束语